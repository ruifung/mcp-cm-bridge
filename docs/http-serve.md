# HTTP Serve Mode

The `serve` command starts codemode-bridge as an HTTP server using the MCP [StreamableHTTP transport](https://modelcontextprotocol.io/docs/concepts/transports#streamable-http), enabling multiple concurrent clients to connect with isolated execution contexts.

This is distinct from the default `run` command, which uses stdio and serves a single client. Use `serve` when you need multi-tenant access, API-style integration, or when the client cannot host a child process.

## Quick Start

```bash
# Start on the default port (localhost:3000)
codemode-bridge serve

# Bind to all interfaces on a custom port
codemode-bridge serve --port 8080 --host 0.0.0.0

# Verify the server is running
curl http://localhost:3000/health
# {"status":"ok"}
```

## Architecture

Each client's `initialize` request creates a fresh `StreamableHTTPServerTransport` + `McpServer` pair. Sessions are identified by a UUID v4 generated by the bridge and tracked in an in-memory map. The `SessionResolver` manages per-session executor instances, ensuring that code executed in one session cannot observe state from another.

```
Client A ──┐                           ┌── Transport A ── McpServer A ── Executor A
            ├── HTTP Server (:3000) ───┤
Client B ──┘   POST/GET/DELETE /mcp   └── Transport B ── McpServer B ── Executor B
               GET /health
```

The bridge creates one executor per session on first tool call (lazy initialisation). A singleton executor is also created at startup and serves as a fallback if per-session executor creation fails.

## Session Isolation

Each HTTP client gets a unique session ID (UUID v4). Executor state is not shared between sessions.

- Global variables set in session A are invisible to session B.
- State persists within a session across multiple tool calls.
- If a per-session executor fails to initialise, the request falls back to the singleton executor. In that case isolation is not active, and a warning is logged.

Example illustrating independent state:

```typescript
// Client A: sets a variable
await clientA.callTool({ name: 'sandbox_eval_js', arguments: { code: 'async () => { globalThis.x = 42; }' } });

// Client B: cannot see Client A's variable
await clientB.callTool({ name: 'sandbox_eval_js', arguments: { code: 'async () => { return globalThis.x; }' } });
// → undefined
```

## Endpoints

| Method   | Path      | Description                                          |
|----------|-----------|------------------------------------------------------|
| `POST`   | `/mcp`    | Send MCP protocol messages (JSON-RPC)                |
| `GET`    | `/mcp`    | Open SSE stream to receive server-sent notifications |
| `DELETE` | `/mcp`    | Close and clean up a session                         |
| `GET`    | `/health` | Health check — returns `{"status":"ok"}`             |

**Session routing via `Mcp-Session-Id` header:**

- The first request must be an MCP `initialize` request sent as a `POST /mcp` without an `Mcp-Session-Id` header. The bridge creates a new session and returns the session ID in the response.
- All subsequent requests for that session must include `Mcp-Session-Id: <uuid>` in the request headers.
- A `POST /mcp` without `Mcp-Session-Id` that is not an `initialize` request is rejected with HTTP 400.

## Configuration Options

All options from the `run` command are available in `serve`, plus two additional flags:

```bash
codemode-bridge serve [options]
  -p, --port <number>    Port to listen on (default: 3000)
      --host <string>    Host/interface to bind to (default: localhost)
  -e, --executor <type>  Force executor type (isolated-vm, vm2, container, deno)
  -s, --servers <names>  Comma-separated list of servers to load
  -c, --config <path>    Path to mcp.json configuration file
  -d, --debug            Enable debug logging
```

The server reads upstream MCP server definitions from the same configuration file as the `run` command (`~/.config/codemode-bridge/mcp.json` by default). See [CLI & Configuration](./cli.md) for the full configuration format.

**Live reload:** The bridge watches `mcp.json` for changes and reconnects upstream servers when the file is modified. However, in HTTP mode this only affects newly created sessions — existing sessions retain the tool definitions they were initialised with. See [Known Limitations](#known-limitations).

## Session Lifecycle

1. Client sends `POST /mcp` with an MCP `initialize` request (no `Mcp-Session-Id` header).
2. The bridge creates a new `StreamableHTTPServerTransport` and `McpServer`, generates a UUID v4 session ID, and stores the transport in the sessions map.
3. The session ID is returned to the client in the response. All subsequent requests include it via `Mcp-Session-Id`.
4. The first tool call for the session lazily initialises a dedicated executor. The idle timer is armed at this point.
5. Each subsequent tool call resets the idle timer. Sessions with no activity for 30 minutes are disposed automatically — the executor is cleaned up and the session is removed from the map.
6. The client can explicitly close a session by sending `DELETE /mcp` with the session's `Mcp-Session-Id` header.
7. If the transport detects the client has disconnected, `transport.onclose` fires and the session is cleaned up.

## Connecting with MCP SDK

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';

const transport = new StreamableHTTPClientTransport(
  new URL('http://localhost:3000/mcp')
);
const client = new Client({ name: 'my-app', version: '1.0.0' });
await client.connect(transport);

// List available tools
const { tools } = await client.listTools();

// Call a tool
const result = await client.callTool({
  name: 'sandbox_eval_js',
  arguments: { code: 'async () => { return 1 + 1; }' }
});
```

The `StreamableHTTPClientTransport` handles session ID negotiation automatically — it stores the ID returned from `initialize` and sends it on all subsequent requests.

## Comparison: Stdio vs HTTP Mode

| Feature               | Stdio (`run`)          | HTTP (`serve`)                    |
|-----------------------|------------------------|-----------------------------------|
| Transport             | stdin/stdout           | HTTP StreamableHTTP               |
| Concurrent clients    | Single                 | Multiple                          |
| Session isolation     | N/A (single session)   | Per-client executor instances     |
| Idle timeout          | None                   | 30 minutes (per session)          |
| Live reload           | Full support           | New sessions only                 |
| Typical use case      | AI assistant integration | Multi-tenant, API access         |

## Security Considerations

The HTTP server has no built-in authentication or rate limiting. Review these points before exposing it on a network.

**Network binding.** The default host is `localhost`, which only accepts local connections. Using `--host 0.0.0.0` exposes the server on all network interfaces. Do this only if you intend network-wide access and have appropriate controls in place.

**No authentication.** Any client that can reach the port can create sessions and execute code. For production deployments, place the server behind a reverse proxy (nginx, Caddy, Traefik) that enforces authentication, TLS termination, and request rate limiting.

**No request body size limit.** The bridge reads the full request body before processing. A large payload will consume memory proportional to its size. Configure a body size limit in your reverse proxy.

**No session cap.** A single client can create an unbounded number of sessions. Constrain this at the reverse proxy level if needed.

A minimal Caddy configuration for a protected deployment:

```
my-bridge.example.com {
    reverse_proxy localhost:3000
    basicauth {
        user <bcrypt-hash>
    }
}
```

## Known Limitations

- **Live reload applies to new sessions only.** When `mcp.json` changes, existing HTTP sessions keep the tool definitions they were initialised
  with. Only sessions created after the reload pick up the new configuration. Full per-session live reload is not yet implemented ([see TODO in `server.ts`](../src/mcp/server.ts)).
- **No built-in authentication or authorisation.** Use a reverse proxy for production deployments.
- **No request body size limit.** A malicious or buggy client can send an arbitrarily large payload.
- **No session cap.** Sessions accumulate until they are explicitly closed or their 30-minute idle timer fires.
